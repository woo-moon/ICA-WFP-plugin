# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ica_map_v2Dialog
                                 A QGIS plugin
 test version of ICA map on 0726
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-07-26
        git sha              : $Format:%H$
        copyright            : (C) 2024 by World Food Program
        email                : Xiaomeng Wu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import jenkspy
import numpy as np
import rasterio
import geopandas as gpd
import pandas as pd
from PyQt5.QtCore import Qt, QFileInfo
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QListWidget, QPushButton, QInputDialog, QMessageBox, QVBoxLayout, QDialog, QLabel, \
    QLineEdit, QHBoxLayout, QDialogButtonBox, QFileDialog, QGroupBox, QComboBox, QListWidgetItem, QFormLayout, \
    QColorDialog, QTextEdit
from osgeo import gdal
from qgis import processing
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis._core import QgsSymbol, QgsRendererCategory, QgsCategorizedSymbolRenderer, Qgis, QgsRasterLayer, \
    QgsVectorLayer, QgsProject, QgsCoordinateReferenceSystem, QgsVectorFileWriter
from qgis._gui import QgsFileWidget, QgsCheckableComboBox, QgsProjectionSelectionWidget, QgsSpinBox
from qgis.utils import iface
from rasterio.features import geometry_mask
from rasterio.mask import mask
from rasterstats import zonal_stats
from scipy.stats import mode

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ica_map_v2_dialog_base.ui'))


class ica_map_v2Dialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(ica_map_v2Dialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.iface = iface
        ## empty dictionary for shocks
        self.shocks = {'Rapid': {}, 'Slow': {}, 'LULC': {}, 'SI': {}}
        self.outputs = {'Rapid': {}, 'Slow': {}, 'LULC': {}, 'SI': {}}
        self.merge = {'Rapid': {}, 'Slow': {}, 'LULC': {}, 'SI': {}}
        self.setupUi()

    def setupUi(self):
        self.setWindowTitle("ICA LULC Classifier")
        self.setGeometry(0, 0, 800, 400)
        main_layout = QHBoxLayout()
        left_layout = QVBoxLayout()

        ## set administration layer
        self.label_input = QLabel('Set Administration Layer and CRS')
        self.Adm_CRSListWidget = QListWidget()
        self.Adm_CRSListWidget.setFixedHeight(30)
        self.setAdm_CRSButton = QPushButton('Set Admin Shapefile and CRS')
        adm_crs_layout = QHBoxLayout()
        adm_crs_layout.addWidget(self.Adm_CRSListWidget)
        adm_crs_layout.addWidget(self.setAdm_CRSButton)
        ## four list widgets for adding shocks for analysis
        self.label_rapid = QLabel('Rapid Shock Analysis')
        self.RapidShockListWidget = QListWidget()
        self.addRapidShockButton = QPushButton('Add Shock')
        self.addRapidShockButton.setFixedWidth(75)
        self.label_slow = QLabel('Slow Shock Analysis')
        self.SlowShockListWidget = QListWidget()
        self.addSlowShockButton = QPushButton('Add Shock')
        self.addSlowShockButton.setFixedWidth(75)
        self.label_lulc = QLabel('Land Use and Land Cover Analysis')
        self.LULCButton = QPushButton('LULC Analysis')
        self.label_checklist = QLabel('Attributes for Analysis')
        self.MergeListWidget = QListWidget(self)
        self.addMergeButton = QPushButton('Add Layers')
        self.removeMergeButton = QPushButton('Remove')
        add_remove_layout = QHBoxLayout()
        add_remove_layout.addWidget(self.addMergeButton)
        add_remove_layout.addWidget(self.removeMergeButton)
        ## Output Directory Widget
        self.label_output_folder = QLabel("Output Folder")
        self.OutputPath = QgsFileWidget()
        self.OutputPath.setStorageMode(QgsFileWidget.GetDirectory)
        ## key buttons
        self.reloadButton = QPushButton('Reload')
        self.runButton = QPushButton('Run Analysis')
        reload_run_layout = QHBoxLayout()
        reload_run_layout.addWidget(self.reloadButton)
        reload_run_layout.addWidget(self.runButton)

        ## Layout
        left_layout.addWidget(self.label_input)
        left_layout.addLayout(adm_crs_layout)
        left_layout.addWidget(self.label_rapid)
        left_layout.addWidget(self.RapidShockListWidget)
        left_layout.addWidget(self.addRapidShockButton)
        left_layout.addWidget(self.label_slow)
        left_layout.addWidget(self.SlowShockListWidget)
        left_layout.addWidget(self.addSlowShockButton)
        left_layout.addWidget(self.label_lulc)
        left_layout.addWidget(self.LULCButton)
        left_layout.addWidget(self.label_checklist)
        left_layout.addWidget(self.MergeListWidget)
        left_layout.addLayout(add_remove_layout)
        left_layout.addWidget(self.label_output_folder)
        left_layout.addWidget(self.OutputPath)
        left_layout.addLayout(reload_run_layout)
        right_layout = QVBoxLayout()
        self.description_text = QTextEdit()
        self.description_text.setReadOnly(True)  # Make it read-only
        # Use HTML to format the text with paragraphs
        self.description_text.setText("""
        <p>Make ICA maps</p>
        <p>This plugin is for spatial analysis in ICA reports required by WFP.</p>
        <p>In module "Set Administration Layer and CRS", click the button "set Admin Shapefile and CRS". In the popping up window, select the shapefile of the country on the proper administrative level (usually the second level), and the CRS will be identified automatically. </p>
        <p>In the module "Rapid Shock Analysis", double click the items in the list. In the popping up window, select the raster layer for the concerning shock. For functions, select the statistical methods (percentage and mean are recommended by WFP). for the Palette, you may want to use the pre-defined Palette, or define a new palette for Class Low, Medium and High. <p>
        <p>In the module "Slow Shock Analysis", double click the items in the list. In the popping up window, select the raster layer for the concerning shock. Set a threshold the years with the concerning shock above which is identified as a shock-threatened year. Use a pre-defined palette or a new palette. <p>
        <p>If the shock you are concerning about is not listed above, click "Add Shock" to activate a new name of shock.<p>
        <p>In the module "LULC Analysis", click the button to activate the window for input data. Select raster layers of land use and land cover (usually more than one year) downloaded from LAADS in base year (like 2001-2003) and recent years (like 2020-2022)here. You can see the land degradation during this period. <p>
        <p>Now you can check all the attributes in the list "Attributes for Analysis". If you want to remove one attribute, select it in the list, and click "Remove". <p>
        <p>By clicking "Add Layers", you can set the shapefile for Food Security, another attribute for ICA besides natural shocks. In the popping window, select the shapefile of the Food Security. The names of all columns are loaded into the box of Select Column. Select the column for analysis. Please be sure the shapefile are prepared with Low, Medium and High classes. <p>
        <p>In the Output Folder, select a folder to reserve all the results, since there will be many. You can also check all the outputs in this folder. <p>
        <p>Click "Run Analysis" to see all the results, or Click "Reload" button to clear all the element for a new project. <p>
        """)
        right_layout.addWidget(self.description_text)

        main_layout.addLayout(left_layout)
        main_layout.addLayout(right_layout)

        self.setLayout(main_layout)
        ## Lay out all the elements

        # Populate the list widget with predefined shocks
        predefined_rapidshocks = ['Flood', 'Landslide']
        for shock in predefined_rapidshocks:
            self.RapidShockListWidget.addItem(shock)

        predefined_slowshocks = ['Drought', 'Erosion']
        for shock in predefined_slowshocks:
            self.SlowShockListWidget.addItem(shock)

        # Connect buttons to their respective functions
        self.setAdm_CRSButton.clicked.connect(self.open_admin_module)
        self.addRapidShockButton.clicked.connect(self.add_custom_rapidshock)
        self.addSlowShockButton.clicked.connect(self.add_custom_slowshock)
        self.runButton.clicked.connect(self.run_analysis)
        self.RapidShockListWidget.itemDoubleClicked.connect(self.configure_rapidshock)
        self.SlowShockListWidget.itemDoubleClicked.connect(self.configure_slowshock)
        self.LULCButton.clicked.connect(self.configure_lulc)
        self.addMergeButton.clicked.connect(self.add_SI)
        self.removeMergeButton.clicked.connect(self.remove_shock)
        self.reloadButton.clicked.connect(self.reload)
    def open_admin_module(self):
        admin_dialog = AdminShapefileCRSModule(self)
        if admin_dialog.exec_() == QDialog.Accepted:
            self.admin_shapefile, self.crs_id = admin_dialog.get_shapefile_and_crs()
        # Load the administration layer
        layer = QgsVectorLayer(self.admin_shapefile, "Admin Layer", "ogr")
        if not layer.isValid():
            raise Exception("Invalid administration shapefile")
        # Get the CRS of the input administration layer
        input_crs = layer.crs()
        # Get the selected CRS
        selected_crs = QgsCoordinateReferenceSystem(self.crs_id)
        # Check if the CRS of the input layer is different from the selected CRS
        if input_crs != selected_crs:
            parameter = {
                'INPUT': self.admin_shapefile,
                'TARGET_CRS': selected_crs,
                'OUTPUT': 'memory:'
            }
            reprojected_layer = processing.run("qgis:reprojectlayer", parameter)['OUTPUT']
            reprojected_file_path = f"{QgsProject.instance().homePath()}/reprojected_admin_layer.shp"
            QgsVectorFileWriter.writeAsVectorFormat(reprojected_layer, reprojected_file_path, "UTF-8", selected_crs, "ESRI Shapefile")
            self.admin_shapefile = reprojected_file_path

        text = f'Adm: {self.admin_shapefile}; CRS: {self.crs_id}'
        self.Adm_CRSListWidget.addItem(text)

    def reload(self):
        self.Adm_CRSListWidget.clear()
        self.MergeListWidget.clear()
        self.setupUi()
    def add_custom_rapidshock(self):
        text, ok = QInputDialog.getText(self, 'Add Custom Shock', 'Enter shock name:')
        if ok and text:
            self.RapidShockListWidget.addItem(text)

    def add_custom_slowshock(self):
        text, ok = QInputDialog.getText(self, 'Add Custom Shock', 'Enter shock name:')
        if ok and text:
            self.SlowShockListWidget.addItem(text)

    def configure_rapidshock(self):
        item = self.RapidShockListWidget.currentItem()
        if item:
            shock_name = item.text()
            dialog = RapidShockConfigDialog(shock_name, self)
            if dialog.exec_() == QDialog.Accepted:
                self.shocks['Rapid'][shock_name] = dialog.get_config()
                self.MergeListWidget.addItem(shock_name)

    def configure_slowshock(self):
        item = self.SlowShockListWidget.currentItem()
        if item:
            shock_name = item.text()
            dialog = SlowShockConfigDialog(shock_name, self)
            if dialog.exec_() == QDialog.Accepted:
                self.shocks['Slow'][shock_name] = dialog.get_config()
                self.MergeListWidget.addItem(shock_name)

    def configure_lulc(self):
        shock_name = 'LULC'
        dialog = LULCConfigDialog(shock_name, self)
        if dialog.exec_() == QDialog.Accepted:
            self.shocks['LULC'][shock_name] = dialog.get_config()
            self.MergeListWidget.addItem(shock_name)

    def add_SI(self):
        text, ok = QInputDialog.getText(self, 'Add A Layer', 'Enter attribute name:')
        if ok and text:
            dialog = ShockParameterDialog(text, self)
            if dialog.exec_() == QDialog.Accepted:
                shapefile, column = dialog.get_config()
                if column and shapefile and column:
                    self.shocks['SI'][text] = dialog.get_config()
                    self.MergeListWidget.addItem(text)

    def config_SI(self):
        dialog = ShockParameterDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            shock_name, shapefile, column = dialog.get_config()
            if shock_name and column and shapefile and column:
                self.shocks['SI'][shock_name] = dialog.get_config()
                self.MergeListWidget.addItem(shock_name)

    def remove_shock(self):
        selected_item = self.MergeListWidget.currentItem()
        if selected_item:
            shock_name = selected_item.text()
            # Check and remove the shock from each category
            for category in self.shocks:
                if shock_name in self.shocks[category]:
                    del self.shocks[category][shock_name]
                    break
            self.MergeListWidget.takeItem(self.MergeListWidget.row(selected_item))
    ## re-project a raster layer.
    ## the output is the path to the layer with right crs (.tif)
    def reproj(self, input_raster_path, obj_crs):
        input_raster = QgsRasterLayer(input_raster_path, "Input Raster Layer")
        input_crs = input_raster.crs()
        print("input_crs: ", input_crs)
        # Get the target CRS
        target_crs = QgsCoordinateReferenceSystem(obj_crs)

        # Check if the CRS of the input layer is different from the target CRS
        if input_crs != target_crs:
            dir_name = os.path.abspath(os.path.dirname(input_raster_path))
            base_name = os.path.splitext(os.path.basename(input_raster_path))[0]
            new_base_name = f"{base_name}_reproj.tif"
            output_raster_path = os.path.join(dir_name, new_base_name)
            print("output_raster_path: ", output_raster_path)
            reprojected_raster = gdal.Warp(output_raster_path, input_raster_path, dstSRS=target_crs.authid())

            return output_raster_path

        else:
            return input_raster_path


    def run_analysis(self):
        self.outputdir = self.OutputPath.filePath()
        print("outputdir: " ,self.outputdir)
        if not self.shocks:
            QMessageBox.warning(self, 'No Shocks Configured', 'Please configure at least one shock for analysis.')
            return
        for shock_name, config in self.shocks.items():
            self.run_analysis_func(shock_name, config)
        # rapid shocks
        if len(self.shocks['Rapid']) != 0:
            shock_index = 0
            for shock_name, config in self.shocks['Rapid'].items():
                shock_index += 1
                print(type(config))
                print(shock_name, shock_index, config)
                self.rapid_shocks(shock_name, shock_index, config)
        # slow shocks
        if len(self.shocks['Slow']) != 0:
            shock_index = 0
            for shock_name, config in self.shocks['Slow'].items():
                shock_index += 1
                print(type(config))
                print(shock_name, shock_index, config)
                self.slow_shocks(shock_name, shock_index, config)
        # lulc
        if len(self.shocks['LULC']) != 0:
            for shock_name, config in self.shocks['LULC'].items():
                print(shock_name, config)
                self.lulc_analysis(shock_name, config)

        ## other attribute, like food insecurity
        if len(self.shocks['SI']) != 0:
            print("Config in SI: ", self.shocks['SI'].items())
            shock_index = 0
            for shock_name, config in self.shocks['SI'].items():
                shock_index += 1
                print(type(config))
                print(shock_index, config)
                self.show_si(config)
        # merge
        if len(self.shocks['Rapid']) != 0:
            self.merge_rapid()
        if len(self.shocks['Slow']) != 0:
            self.merge_slow()
        if len(self.shocks['Rapid'])*len(self.shocks['Slow']) !=0:
            self.merge_hazard()
            if len(self.shocks['Rapid'])*len(self.shocks['Slow'])*len(self.shocks['SI']) !=0:
                self.merge_ica()

    def rapid_shocks(self, shock_name,shock_index, config):
    # define a customized function for percentage
        def custom_zonal_stats(geometry, raster_path, custom_stats=None):
            if custom_stats is None:
                custom_stats = {}

            with rasterio.open(raster_path) as src:
                geom = [geometry]  # Geometry should be a shapely geometry object
                mask = geometry_mask(geom, transform=src.transform, invert=True, out_shape=(src.height, src.width))

                data = src.read(1)
                masked_data = np.where(mask, data, np.nan)

                custom_results = {}
                if 'percent' in custom_stats:
                    total_pixels = np.sum(~np.isnan(masked_data))
                    non_zero_pixels = np.sum(masked_data > 0)
                    custom_results['percent'] = (non_zero_pixels / total_pixels) * 100 if total_pixels > 0 else np.nan

                return custom_results

        def apply_symbology(layer, palette):
            # Define the symbology based on the selected palette
            categories = []

            for class_value, color_name in palette.items():
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(QColor(color_name))
                category = QgsRendererCategory(class_value, symbol, class_value)
                categories.append(category)

            # Create a renderer and assign it to the layer
            renderer = QgsCategorizedSymbolRenderer(f'rcls_{shock_index}', categories)
            layer.setRenderer(renderer)
            layer.triggerRepaint()

        # Get the file paths for the selected raster and shapefile layers
        raster_path = config['shock_layer']
        shapefile_path = self.admin_shapefile
        output_file_path = self.outputdir
        function_names = config['functions']
        result_crs = self.crs_id
        selected_palette = config['palette']
        print(config)

        # Separate built-in statistics from custom statistics
        built_in_stats = ['count', 'min', 'max', 'mean', 'sum', 'std', 'median', 'majority', 'minority', 'unique',
                          'range', 'nodata', 'nan']
        custom_stats = [stat for stat in function_names if stat not in built_in_stats]
        # Ensure only valid built-in stats are passed to zonal_stats
        valid_function_names = [stat for stat in function_names if stat in built_in_stats]

        # Check that both file paths are valid
        if not raster_path or not shapefile_path:
            iface.messageBar().pushMessage("Error", "Please select both a raster and a shapefile layer.",
                                           level=Qgis.Critical, duration=5)
            return
        shapefile_layer = gpd.read_file(shapefile_path)
        print(shapefile_layer.crs)
        raster_layer = QgsRasterLayer(raster_path, 'raster')
        print(raster_layer.crs().authid())


        # check if valid
        shapefile_layer['is_valid'] = shapefile_layer.is_valid
        if not shapefile_layer['is_valid'].all():
            print("Shapefile Not Valid")
            admin_shapes = shapefile_layer.buffer(0)
            admin_shapes['is_valid'] = admin_shapes.is_valid
            print("Fixed invalid geometries.")

        # check if the crs matches
        raster_path = self.reproj(input_raster_path=raster_path, obj_crs=result_crs)
        # Dictionary to store statistics for each administration
        admin_stats = {method: [] for method in function_names}
        # classification function
        for _, row in shapefile_layer.iterrows():
            geometry = row.geometry
            stats = zonal_stats(geometry, raster_path, stats = valid_function_names)[0]
            for method in valid_function_names:
                admin_stats[method].append(stats[method])

            # Calculate custom statistics
            custom_results = custom_zonal_stats(geometry, raster_path, custom_stats=custom_stats)
            for method in custom_stats:
                admin_stats[method].append(custom_results[method])

        for method in function_names:
            data = np.array(admin_stats[method])
            data = np.where(data == None, np.nan, data)
            valid_data = data[~np.isnan(data)]
            breaks = jenkspy.jenks_breaks(valid_data, n_classes=3)
            class_column = f'class_{method}'
            shapefile_layer[class_column] = pd.cut(data, bins=breaks,
                                                   labels=[1,2,3],
                                                   include_lowest=True).astype(str)
        # the final class
        shapefile_layer[f'rcls_{shock_index}'] =None
        # Iterate over each row in the shapefile layer
        for idx, row in shapefile_layer.iterrows():

            # Calculate the sum of the class labels for that row
            sum_labels = 0
            for method in function_names:
                class_label = int(row[f'class_{method}'])
                sum_labels += class_label

            # Determine the final class based on the number of methods and the sum of the labels
            if len(function_names) == 1:
                # Use the class label from the single method
                final_class = row[f'class_{function_names[0]}']
            else:
                # Determine the final class based on the sum of the labels
                avg_labels = len(function_names) * 2
                if sum_labels < avg_labels:
                    final_class = 'Low'
                elif sum_labels == avg_labels:
                    final_class = 'Medium'
                else:
                    final_class = 'High'

            # Set the final class for that row
            shapefile_layer.at[idx, f'rcls_{shock_index}'] = final_class

        output_path = os.path.join(output_file_path, f'{shock_name}_shocks.shp')
        shapefile_layer.to_file(output_path, driver='ESRI Shapefile')
        self.outputs['Rapid'][shock_name] = output_path
        print(self.outputs)

        # Add the results layer to the QGIS interface
        result_layer = QgsVectorLayer(output_path, shock_name, "ogr")
        if not result_layer.isValid():
            iface.messageBar().pushMessage("Error", "Failed to load the results layer.",
                                           level=Qgis.Critical, duration=5)
        else:
            # apply the symbology
            apply_symbology(result_layer, selected_palette)
            QgsProject.instance().addMapLayer(result_layer)
        # Show a message to the user
        # cannot find the iface in self
        self.iface.messageBar().pushMessage("Analysis complete",
                                            "The results have been saved to {} and fadded to the map canvas.".format(
                                                output_path), level=Qgis.Info, duration=5)

    def slow_shocks(self, shock_name, shock_index, config):
        def apply_symbology(layer, palette):
            # Define the symbology based on the selected palette
            categories = []

            for class_value, color_name in palette.items():
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(QColor(color_name))
                category = QgsRendererCategory(class_value, symbol, class_value)
                categories.append(category)

            # Create a renderer and assign it to the layer
            renderer = QgsCategorizedSymbolRenderer(f'scls_{shock_index}', categories)
            layer.setRenderer(renderer)
            layer.triggerRepaint()

        admin_shapefile = self.admin_shapefile
        slowshocks_layers = config['shock_layers']
        thd = config['threshold']
        output_folder = self.outputdir
        result_crs = self.crs_id
        palette = config['palette']
        print("slow config: ", config)

        # percentage of drought pixel
        def drought_pct(admin_shapefile, raster_path, threshold):
            # Read the shapefile
            adm_layer = gpd.read_file(admin_shapefile)

            # Open the raster file
            with rasterio.open(raster_path) as src:
                drought_percentages = []

                # Iterate through each administration's geometry
                for geom in adm_layer.geometry:
                    # Mask the raster with the current administration's geometry
                    out_image, out_transform = mask(src, [geom], crop=True)
                    out_image = out_image[0]  # Extract the single band

                    # Determine drought pixels
                    drought_pixels = (out_image > threshold).astype(int)
                    total_pixels = np.sum(~np.isnan(out_image))  # Count non-NaN pixels

                    # Calculate the percentage of drought pixels
                    drought_percentage = np.sum(drought_pixels) / total_pixels if total_pixels > 0 else 0
                    drought_percentages.append(drought_percentage)

            # Add the drought percentage to the GeoDataFrame
            # adm_layer['drought_percentage'] = drought_percentages

            # Add the drought percentage to the GeoDataFrame
            adm_layer['drt_pct'] = drought_percentages

            return adm_layer

        # drought majority
        def drought_majority(adm_shapefile, raster_path):
            # Read the shapefile
            adm_layer = gpd.read_file(adm_shapefile)

            # Open the raster file
            with rasterio.open(raster_path) as src:
                drought_majorities = []

                # Iterate through each administration's geometry
                for geom in adm_layer.geometry:
                    # Mask the raster with the current administration's geometry
                    out_image, out_transform = mask(src, [geom], crop=True)
                    out_image = out_image[0]  # Extract the single band

                    # Calculate the majority value
                    valid_pixels = out_image[~np.isnan(out_image)]
                    if len(valid_pixels) > 0:
                        # Use mode to find the most common value
                        majority_value = mode(valid_pixels.ravel(), nan_policy='omit')
                        print(majority_value.mode)
                        # Check if majority_value is a scalar or array and handle appropriately
                        if majority_value.count.size > 0:
                            majority_value = majority_value.mode
                        else:
                            majority_value = np.nan
                    else:
                        majority_value = np.nan

                    drought_majorities.append(majority_value)

            # Add the drought majority to the GeoDataFrame
            adm_layer['drt_mj'] = drought_majorities
            return adm_layer

        # classifier
        def classifier(adm, column_input, column_output):
            valid_data = adm[column_input]
            valid_data = valid_data[~np.isnan(valid_data)]
            breaks = jenkspy.jenks_breaks(valid_data, n_classes=3)

            cls = pd.cut(adm[column_input], bins=breaks,
                         labels=[1, 2, 3],
                         include_lowest=True).astype(int)
            adm[column_output] = cls
            return adm

        # re-project drought layers
        slowshocks_layer = self.reproj(input_raster_path=slowshocks_layers, obj_crs=result_crs)

        adm_pct = drought_pct(admin_shapefile=admin_shapefile, raster_path=slowshocks_layer, threshold=thd)
        adm_mj = drought_majority(adm_shapefile=admin_shapefile, raster_path=slowshocks_layer)
        adm_pct['drt_mj'] = adm_mj['drt_mj']

        adm_pct = classifier(adm=adm_pct, column_output='pct_cls', column_input='drt_pct')
        adm_pct = classifier(adm=adm_pct, column_input='drt_mj', column_output='mj_cls')
        print(adm_pct['pct_cls'])
        print(adm_pct['mj_cls'])
        adm_pct[f'scls_{shock_index}'] = None
        # Iterate over each row in the shapefile layer
        for idx, row in adm_pct.iterrows():
            # Calculate the sum of the class labels for that row
            sum_labels = row['mj_cls'] + row['pct_cls']

            if sum_labels < 4:
                final_class = 'Low'
            elif sum_labels == 4:
                final_class = 'Medium'
            else:
                final_class = 'High'
            adm_pct.at[idx, f'scls_{shock_index}'] = final_class

        print("calculation ends")
        output_path = os.path.join(output_folder, 'slowshocks.shp')
        self.outputs['Slow'][shock_name] = output_path
        print(self.outputs)
        adm_pct.to_file(output_path, driver='ESRI Shapefile')

        # Add the results layer to the QGIS interface
        slowshocks_result = QgsVectorLayer(output_path,shock_name, "ogr")
        if not slowshocks_result.isValid():
            iface.messageBar().pushMessage("Error", "Failed to load the result of slow shocks.",
                                           level=Qgis.Critical, duration=5)
        else:
            # apply the symbology
            apply_symbology(slowshocks_result, palette)
            QgsProject.instance().addMapLayer(slowshocks_result)
        # Show a message to the user
        # cannot find the iface in self
        self.iface.messageBar().pushMessage("Slow Shocks analysis complete",
                                            "The results have been saved to {} and fadded to the map canvas.".format(                                           output_path), level=Qgis.Info, duration=5)

    def lulc_analysis(self, shocks, config):
        def eco_value(raster_layers):
            # Define the bins and corresponding ecological values
            bins = [-1, 6, 9, 11, 12, 13, 14, 15, 16, 21]
            values = [6, 5, 4, 6, 3, 1, 3, 2, 0]

            def map_eco_values(data):
                # Replace invalid values with 0
                data[np.isnan(data)] = 0
                data[np.isinf(data)] = 0
                data_min = data.min()
                data_max = data.max()
                bins = [data_min, 6, 9, 11, 12, 13, 14, 15, 16, data_max]
                values = [6, 5, 4, 6, 3, 1, 3, 2, 0]
                # Use np.digitize to map land use values to ecological values based on bins
                indices = np.digitize(data, bins, right=True) - 1
                eco_data = np.array([values[i] for i in indices.flatten()]).reshape(data.shape)
                return eco_data, data

            eco_layers = []
            for layer in raster_layers:
                with rasterio.open(layer) as src:
                    data = src.read(1)
                    eco_data, data = map_eco_values(data)
                    meta = src.meta.copy()

                    # Calculate and print the mean of the land use index in the input layer
                    mean_land_use_index = np.mean(data)
                    print(f"Mean land use index in {layer}: {mean_land_use_index}")

                    # Calculate and print the mean of the ecological value in the output layer
                    mean_eco_value = np.mean(eco_data)
                    print(f"Mean ecological value in {layer}: {mean_eco_value}")

                    eco_layers.append((eco_data, meta))

            return eco_layers

        # define mean_value function
        def mean_value( eco_layers):
            sum_data = None
            count = len(eco_layers)

            for eco_data, meta in eco_layers:
                if sum_data is None:
                    sum_data = eco_data.astype(float)
                else:
                    sum_data += eco_data

            mean_data = sum_data / count
            print('mean_data: ', mean_data)
            return mean_data, meta

        # Define np_lulc function
        def np_lulc(admin_shapefile, lulc_array, lulc_meta=None):
            gdf = gpd.read_file(admin_shapefile)
            pos_class = []
            neg_class = []
            mean_class = []

            for idx, row in gdf.iterrows():
                geom = [row['geometry']]
                mask = geometry_mask(geom, transform=lulc_meta['transform'], invert=True, out_shape=lulc_array.shape)

                masked_data = np.where(mask, lulc_array, np.nan)

                mean_lulc = np.nanmean(masked_data)
                pos_perc = np.nansum(masked_data > 0) / np.count_nonzero(~np.isnan(masked_data))
                neg_perc = np.nansum(masked_data < 0) / np.count_nonzero(~np.isnan(masked_data))
                pos_class.append(pos_perc)
                neg_class.append(neg_perc)
                mean_class.append(mean_lulc)

            pos_breaks = jenkspy.jenks_breaks(pos_class, n_classes=3)
            neg_breaks = jenkspy.jenks_breaks(neg_class, n_classes=3)
            pos_class = pd.cut(pos_class, bins=pos_breaks, labels=[1, 2, 3],
                               include_lowest=True)
            neg_class = pd.cut(neg_class, bins=neg_breaks, labels=[1, 2, 3],
                               include_lowest=True)
            gdf['mean_lulc'] = mean_class
            gdf['np_lulc'] = np.zeros(len(gdf))

            for idx, row in gdf.iterrows():
                mean_lulc = row['mean_lulc']
                pos_class_val = pos_class[idx]
                neg_class_val = neg_class[idx]

                if mean_lulc > 0:
                    gdf.at[idx, 'np_lulc'] = pos_class_val
                elif mean_lulc < 0:
                    gdf.at[idx, 'np_lulc'] = -neg_class_val

            reclassification_map = {
                -1: "High Negative Change",
                -2: "Medium Negative Change",
                -3: "Low Negative Change",
                0: "No Change",
                1: "Low Positive Change",
                2: "Medium Positive Change",
                3: "High Positive Change"
            }
            gdf['lulc_cls'] = gdf['np_lulc'].map(reclassification_map)
            return gdf

        # color
        def apply_symbology(layer):
            # Define the color palette
            palette = {
                "High Positive Change": '#33CC33',
                "Medium Positive Change": '#AAFF00',
                "Low Positive Change": '#E9FFBE',
                "No Change": '#ffffff',
                "High Negative Change": '#A25100',
                "Medium Negative Change": '#DA6D00',
                "Low Negative Change": '#FFAC58'
            }

            # Create categories for the renderer
            categories = []
            for value, color in palette.items():
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(QColor(color))
                category = QgsRendererCategory(value, symbol, str(value))
                categories.append(category)

            # Create the renderer
            renderer = QgsCategorizedSymbolRenderer('lulc_cls', categories)

            # Apply the renderer to the layer
            layer.setRenderer(renderer)
            layer.triggerRepaint()

        admin_shapefile=self.admin_shapefile
        past_land_use_layers=config['past_lu'].strip('"').split('" "')
        print(past_land_use_layers)
        recent_land_use_layers= config['recent_lu'].strip('"').split('" "')
        print(recent_land_use_layers)
        result_crs = self.crs_id
        output_folder=self.outputdir


        # check if layers are in the same crs.
        past_land_use_layers_reproj = []
        for layer in past_land_use_layers:
            layer_path = self.reproj(input_raster_path= layer, obj_crs= result_crs)
            past_land_use_layers_reproj.append(layer_path)
        print(past_land_use_layers_reproj)

        recent_land_use_layers_reproj = []
        for layer in recent_land_use_layers:
            layer_path = self.reproj(input_raster_path= layer, obj_crs= result_crs)
            recent_land_use_layers_reproj.append(layer_path)
        print(recent_land_use_layers_reproj)

        # Step 1: Re-classify all the raster layers with the function eco_value
        past_eco_layers = eco_value(raster_layers=past_land_use_layers_reproj)
        recent_eco_layers = eco_value(raster_layers=recent_land_use_layers_reproj)
        # Step 2: Define two raster layers, past_lu and recent_lu
        past_lu, meta = mean_value(past_eco_layers)
        recent_lu, _ = mean_value(recent_eco_layers)

        # Step 3: Define a raster layer named "diff_lu"
        diff_lu = recent_lu - past_lu

        # Step 4: Calculate the np_lulc with the function np_lulc for all administrations
        admin_np_lulc = np_lulc(admin_shapefile, diff_lu, meta)

        # Step 5: Put the result layer to the output folder
        output_path = os.path.join(output_folder, 'admin_np_lulc.shp')
        admin_np_lulc.to_file(output_path)

        # Add the results layer to the QGIS interface
        result_layer = QgsVectorLayer(output_path, "LULC", "ogr")
        if not result_layer.isValid():
            iface.messageBar().pushMessage("Error", "Failed to load the results layer.",
                                           level=Qgis.Critical, duration=5)
        else:
            # apply the symbology
            apply_symbology(result_layer)
            QgsProject.instance().addMapLayer(result_layer)
        # Show a message to the user
        self.iface.messageBar().pushMessage("Analysis complete",
                                            "The results have been saved to {} and fadded to the map canvas.".format(output_path), level=Qgis.Info, duration = 5)

    def run_analysis_func(self, shock_name, config):
        # for shock in shock_name['Rapid']


        print(f"Running analysis for {shock_name} with config: {config}")
        # Example usage:
        # rapid_shock(config['raster_layer'], config['vector_layer'], config['threshold'])

    def merge_rapid(self):
        # define colors for rapid
        def apply_symbology(layer):
            # Define the color palette
            palette = {
                "High": '#8b31cf',
                "Medium": '#b57be1',
                "Low": '#d5b4ee'
            }

            # Create categories for the renderer
            categories = []
            for value, color in palette.items():
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(QColor(color))
                category = QgsRendererCategory(value, symbol, str(value))
                categories.append(category)

            # Create the renderer
            renderer = QgsCategorizedSymbolRenderer('rcls_m', categories)

            # Apply the renderer to the layer
            layer.setRenderer(renderer)
            layer.triggerRepaint()

        # Define a function to reclassify the columns
        def reclassify(row):
            # Extract the values from the columns starting with "rcls_"
            values = row.filter(regex="^rcls_").values

            # Replace the values with their corresponding numeric values
            values[values == "High"] = 3
            values[values == "Medium"] = 2
            values[values == "Low"] = 1

            # Calculate the sum of the values
            sum_values = values.sum()

            # Determine the reclassified value based on the sum
            if sum_values > 2 * len(values):
                return "High"
            elif sum_values == 2 * len(values):
                return "Medium"
            else:
                return "Low"

        shock_names = self.outputs['Rapid'].keys()
        shapefiles = []
        for sub_dict in self.outputs['Rapid'].values():
            output_path = sub_dict
            gdf = gpd.read_file(output_path)
            print("Rapid: ", output_path)
            shapefiles.append(gdf)
        merged_gdf = shapefiles[0]

        for gdf in shapefiles[1:]:
            print("gdf: ", gdf.columns)
            merged_gdf = gpd.sjoin(merged_gdf, gdf, how='inner', op='intersects')
            merged_gdf = merged_gdf.drop(columns=['index_left', 'index_right'], errors='ignore')

        merged_gdf = merged_gdf.drop_duplicates(subset='geometry')
        merged_gdf = merged_gdf.loc[:, ~merged_gdf.columns.str.startswith('index_')]
        merged_gdf["rcls_m"] = merged_gdf.apply(reclassify, axis=1)
        output_merge_path = os.path.join(os.path.dirname(output_path),
                                   'merged rapid shocks.shp')
        merged_gdf.to_file(output_merge_path)

        self.merge['Rapid'] = output_merge_path
        print(self.merge)
        # Add the results layer to the QGIS interface
        result_layer = QgsVectorLayer(output_merge_path, "Merged_Rapid", "ogr")
        if not result_layer.isValid():
            iface.messageBar().pushMessage("Error", "Failed to load the results layer.",
                                           level=Qgis.Critical, duration=5)
        else:
            # apply the symbology
            apply_symbology(result_layer)
            QgsProject.instance().addMapLayer(result_layer)
        # Show a message to the user
        # cannot find the iface in self
        self.iface.messageBar().pushMessage("Analysis complete",
                                            "The results have been saved to {} and fadded to the map canvas.".format(
                                                output_path), level=Qgis.Info, duration=5)

    def merge_slow(self):
        # define colors for rapid
        def apply_symbology(layer):
            # Define the color palette
            palette = {
                "High": '#8b31cf',
                "Medium": '#b57be1',
                "Low": '#d5b4ee'
            }

            # Create categories for the renderer
            categories = []
            for value, color in palette.items():
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(QColor(color))
                category = QgsRendererCategory(value, symbol, str(value))
                categories.append(category)

            # Create the renderer
            renderer = QgsCategorizedSymbolRenderer('scls_m', categories)

            # Apply the renderer to the layer
            layer.setRenderer(renderer)
            layer.triggerRepaint()

        # Define a function to reclassify the columns
        def reclassify(row):
            # Extract the values from the columns starting with "rcls_"
            values = row.filter(regex="^scls_").values

            # Replace the values with their corresponding numeric values
            values[values == "High"] = 3
            values[values == "Medium"] = 2
            values[values == "Low"] = 1

            # Calculate the sum of the values
            sum_values = values.sum()

            # Determine the reclassified value based on the sum
            if sum_values > 2 * len(values):
                return "High"
            elif sum_values == 2 * len(values):
                return "Medium"
            else:
                return "Low"

        shock_names = self.outputs['Slow'].keys()
        shapefiles = []
        for sub_dict in self.outputs['Slow'].values():
            output_path = sub_dict
            gdf = gpd.read_file(output_path)
            shapefiles.append(gdf)
        merged_gdf = shapefiles[0]
        for gdf in shapefiles[1:]:
            merged_gdf = gpd.sjoin(merged_gdf, gdf, how='inner', op='intersects')
            merged_gdf = merged_gdf.drop(columns=['index_left', 'index_right'], errors='ignore')

        # Remove duplicate geometries if needed
        merged_gdf = merged_gdf.drop_duplicates(subset='geometry')
        merged_gdf = merged_gdf.loc[:, ~merged_gdf.columns.str.startswith('index_')]
        merged_gdf["scls_m"] = merged_gdf.apply(reclassify, axis=1)
        output_merge_path = os.path.join(os.path.dirname(output_path),
                                   'merged slow shocks.shp')
        merged_gdf.to_file(output_merge_path)

        # Add the results layer to the QGIS interface
        result_layer = QgsVectorLayer(output_merge_path, "Merged_Slow", "ogr")
        if not result_layer.isValid():
            iface.messageBar().pushMessage("Error", "Failed to load the results layer.",
                                           level=Qgis.Critical, duration=5)
        else:
            # apply the symbology
            apply_symbology(result_layer)
            QgsProject.instance().addMapLayer(result_layer)
            self.merge['Slow'] = output_merge_path
            print(self.merge)
        # Show a message to the user
        # cannot find the iface in self
        self.iface.messageBar().pushMessage("Analysis complete",
                                            "The results have been saved to {} and fadded to the map canvas.".format(
                                                output_merge_path), level=Qgis.Info, duration=5)

    def merge_hazard(self):
        print(self.merge)
        # define colors for rapid
        def apply_symbology(layer):
            # Define the color palette
            palette = {
                "High": '#416073',
                "Medium": '#89a9bd',
                "Low": '#b4c8d4'
            }

            # Create categories for the renderer
            categories = []
            for value, color in palette.items():
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(QColor(color))
                category = QgsRendererCategory(value, symbol, str(value))
                categories.append(category)

            # Create the renderer
            renderer = QgsCategorizedSymbolRenderer('hzd', categories)

            # Apply the renderer to the layer
            layer.setRenderer(renderer)
            layer.triggerRepaint()

        # Define a function to reclassify the columns
        def reclassify(row):
            # Extract the values from the columns starting with "rcls_"
            values = row.filter(regex="cls_m$").values

            # Replace the values with their corresponding numeric values
            values[values == "High"] = 3
            values[values == "Medium"] = 2
            values[values == "Low"] = 1

            # Calculate the sum of the values
            sum_values = values.sum()

            # Determine the reclassified value based on the sum
            if sum_values > 2 * len(values):
                return "High"
            elif sum_values == 2 * len(values):
                return "Medium"
            else:
                return "Low"

        shapefiles = []
        rapid = gpd.read_file(self.merge['Rapid'])
        slow = gpd.read_file(self.merge['Slow'])
        shapefiles = [rapid, slow]
        merged_gdf = shapefiles[0]
        for gdf in shapefiles[1:]:
            merged_gdf = gpd.sjoin(merged_gdf, gdf, how='inner', op='intersects')
            merged_gdf = merged_gdf.drop(columns=['index_left', 'index_right'], errors='ignore')

        # Remove duplicate geometries if needed
        merged_gdf = merged_gdf.drop_duplicates(subset='geometry')
        merged_gdf = merged_gdf.loc[:, ~merged_gdf.columns.str.startswith('index_')]
        merged_gdf["hzd"] = merged_gdf.apply(reclassify, axis=1)
        output_merge_path = os.path.join(os.path.dirname(self.merge['Slow']),
                                   'merged hazard.shp')
        merged_gdf.to_file(output_merge_path)
        self.merge['Hazard'] = output_merge_path
        print(self.merge)
        result_layer = QgsVectorLayer(output_merge_path, "Merged_Hazard", "ogr")
        if not result_layer.isValid():
            iface.messageBar().pushMessage("Error", "Failed to load the results layer.",
                                           level=Qgis.Critical, duration=5)
        else:
            # apply the symbology
            apply_symbology(result_layer)
            QgsProject.instance().addMapLayer(result_layer)

        # Show a message to the user
        # cannot find the iface in self
        self.iface.messageBar().pushMessage("Analysis complete",
                                            "The results have been saved to {} and fadded to the map canvas.".format(
                                                output_merge_path), level=Qgis.Info, duration=5)

    def show_si(self, config):
        def apply_symbology(layer, column_name):
            # Define the color palette
            palette = {
                "High": '#D23C00',
                "Medium": '#FF7E4B',
                "Low": '#FFB597'
            }

            # Create categories for the renderer
            categories = []
            for value, color in palette.items():
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                print(symbol)
                symbol.setColor(QColor(color))
                category = QgsRendererCategory(value, symbol, str(value))
                categories.append(category)

            # Create the renderer
            renderer = QgsCategorizedSymbolRenderer(column_name, categories)

            # Apply the renderer to the layer
            layer.setRenderer(renderer)
            layer.triggerRepaint()

        shapefile_path = config['shapefile_path']
        selected_column = config['selected_column']
        layer = QgsVectorLayer(shapefile_path, "layer", "ogr")
        if not layer.isValid():
            raise Exception("Invalid shapefile")
        # Get the CRS of the input administration layer
        input_crs = layer.crs().authid()
        print("SI CRS: ", input_crs)
        # Get the selected CRS
        selected_crs = self.crs_id
        print("Selected crs: ",  selected_crs)
        # Check if the CRS of the input layer is different from the selected CRS
        if input_crs != selected_crs:
            parameter = {
                'INPUT': shapefile_path,
                'TARGET_CRS': selected_crs,
                'OUTPUT': 'memory:'
            }
            reprojected_layer = processing.run("qgis:reprojectlayer", parameter)['OUTPUT']
            reprojected_file_path = f"{self.outputdir}/reprojected_SI_layer.shp"
            print(reprojected_file_path)
            QgsVectorFileWriter.writeAsVectorFormat(reprojected_layer, reprojected_file_path, "UTF-8", QgsCoordinateReferenceSystem(self.crs_id), "ESRI Shapefile")
            shapefile_path = reprojected_file_path

        self.si_path = shapefile_path
        print("SI_PATH: ", self.si_path)
        self.si_column = selected_column
        print("SI_COLUMN: ", self.si_column)

        shapefile_layer = QgsVectorLayer(self.si_path, "layer", "ogr")
        apply_symbology(shapefile_layer, selected_column)
        QgsProject.instance().addMapLayer(shapefile_layer)


    def merge_ica(self):
        def apply_symbology(layer):
            # Define the color palette for ICA map
            palette = {
                "Category 1": '#7030a0',
                "Category 2": '#ff0000',
                "Category 3": '#ffa401',
                "Category 4": '#ffff00',
                "Category 5": '#ccff99'
            }
            # Create categories for the renderer
            categories = []
            for value, color in palette.items():
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(QColor(color))
                category = QgsRendererCategory(value, symbol, str(value))
                categories.append(category)

            # Create the renderer
            renderer = QgsCategorizedSymbolRenderer('ICA', categories)

            # Apply the renderer to the layer
            layer.setRenderer(renderer)
            layer.triggerRepaint()

        def reclassify(row, attr):
            com = (row['hzd'], row[attr])
            mapping = {
                ('Low', 'Low'): 'Category 5',
                ('Low', 'Medium'): 'Category 3',
                ('Low', 'High'): 'Category 3',
                ('Medium', 'Low'): 'Category 4',
                ('Medium', 'Medium'): 'Category 2',
                ('Medium', 'High'): 'Category 1',
                ('High', 'Low'): 'Category 4',
                ('High', 'Medium'): 'Category 2',
                ('High', 'High'): 'Category 1',
            }
            return mapping.get(com, 'Unknown')

        natural_hzd = gpd.read_file(self.merge['Hazard'])
        other_attr = gpd.read_file(self.si_path)
        print("other_attr: ", other_attr)
        shapefiles = [natural_hzd, other_attr]
        ica_gdf = shapefiles[0]
        for gdf in shapefiles[1:]:
            ica_gdf = gpd.sjoin(ica_gdf, gdf, how='inner', op='intersects')
            ica_gdf = ica_gdf.drop(columns=['index_left', 'index_right'], errors='ignore')

        # Remove duplicate geometries if needed
        ica_gdf = ica_gdf.drop_duplicates(subset='geometry')
        ica_gdf = ica_gdf.loc[:, ~ica_gdf.columns.str.startswith('index_')]

        ica_gdf["ICA"] = ica_gdf.apply(lambda row: reclassify(row, attr=self.si_column), axis=1)
        output_merge_path = os.path.join(self.outputdir,
                                   'icamap.shp')
        ica_gdf.to_file(output_merge_path)
        self.merge['ica'] = output_merge_path
        print(self.merge)
        result_layer = QgsVectorLayer(output_merge_path, "ICA_Map", "ogr")
        if not result_layer.isValid():
            iface.messageBar().pushMessage("Error", "Failed to load the results layer.",
                                           level=Qgis.Critical, duration=5)
        else:
            # apply the symbology
            apply_symbology(result_layer)
            QgsProject.instance().addMapLayer(result_layer)

        # Show a message to the user
        # cannot find the iface in self
        self.iface.messageBar().pushMessage("Analysis complete",
                                            "The results have been saved to {} and fadded to the map canvas.".format(
                                                output_merge_path), level=Qgis.Info, duration=5)

class AdminShapefileCRSModule(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi()

    def setupUi(self):
        self.setWindowTitle("Administration Shapefile and CRS Selection")
        self.setGeometry(100, 100, 400, 200)
        self.layout = QVBoxLayout()

        # Administration Shapefile Selection
        self.shapefile_label = QLabel("Select Administration Shapefile:", self)
        self.shapefile_edit = QLineEdit(self)
        self.shapefile_edit.setReadOnly(True)
        self.select_shapefile_button = QPushButton("Select Shapefile", self)
        self.select_shapefile_button.clicked.connect(self.select_shapefile)

        shapefile_layout = QHBoxLayout()
        shapefile_layout.addWidget(self.shapefile_edit)
        shapefile_layout.addWidget(self.select_shapefile_button)

        self.layout.addWidget(self.shapefile_label)
        self.layout.addLayout(shapefile_layout)

        # CRS Selection
        self.crs_label = QLabel("Select CRS:", self)
        self.crs_widget = QgsProjectionSelectionWidget(self)
        self.layout.addWidget(self.crs_label)
        self.layout.addWidget(self.crs_widget)

        # Buttons
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.layout.addWidget(self.button_box)

        self.setLayout(self.layout)

    def select_shapefile(self):
        shapefile, _ = QFileDialog.getOpenFileName(self, "Select Administration Shapefile", "", "Vector Files (*.shp *.geojson *.gpkg)")
        if shapefile:
            self.shapefile_edit.setText(shapefile)
            layer = QgsVectorLayer(shapefile, "Selected Layer", "ogr")
            if layer.isValid():
                crs = layer.crs()
                self.crs_widget.setCrs(crs)

    def get_shapefile_and_crs(self):
        return self.shapefile_edit.text(), self.crs_widget.crs().authid()

class RapidShockConfigDialog(QDialog):
    def __init__(self, shock_name, parent=None):
        super().__init__(parent)
        self.shock_name = shock_name
        self.setupUi()

    def setupUi(self):
        self.setWindowTitle("Click test")
        self.setGeometry(0, 0, 432, 384)

        self.layout = QVBoxLayout()

        # Shock Layer
        self.label_shock_layer = QLabel("Shock Layer", self)
        self.label_shock_layer.setGeometry(20, 30, 71, 20)
        self.InputShockLayer = QgsFileWidget(self)
        self.InputShockLayer.setGeometry(140, 30, 231, 27)

        # Functions
        self.label_functions = QLabel("Functions", self)
        self.label_functions.setGeometry(20, 114, 47, 20)
        self.FunctionCombox = QgsCheckableComboBox(self)
        self.FunctionCombox.setGeometry(140, 110, 231, 21)
        functions = [
            "mean", "percent", "count", "min", "max", "sum", "std",
            "median", "majority", "minority", "unique", "range", "nodata", "nan"
        ]
        self.FunctionCombox.addItems(functions)

        # Palette
        self.label_palette = QLabel("Palette", self)
        self.label_palette.setGeometry(20, 230, 91, 16)
        self.PaletteCombox = QComboBox(self)
        self.PaletteCombox.setGeometry(140, 230, 231, 22)
        self.PaletteCombox.addItems(["Flood", "Landslide", "Define new palette..."])
        self.PaletteCombox.currentIndexChanged.connect(self.check_define_palette)

        # Buttons
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        self.button_box.setGeometry(40, 290, 341, 32)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)

        self.layout.addWidget(self.label_shock_layer)
        self.layout.addWidget(self.InputShockLayer)
        self.layout.addWidget(self.label_functions)
        self.layout.addWidget(self.FunctionCombox)
        self.layout.addWidget(self.label_palette)
        self.layout.addWidget(self.PaletteCombox)
        self.layout.addWidget(self.button_box)

        self.setLayout(self.layout)
        self.custom_palette = {'Low': '#b4c8d4', 'Medium': '#89a9bd', 'High': '#416073'}

    def check_define_palette(self, index):
        if self.PaletteCombox.itemText(index) == "Define new palette...":
            dialog = DefinePaletteDialog(self)
            if dialog.exec_() == QDialog.Accepted:
                self.custom_palette = dialog.get_palette()
                # Add custom palette to combo box
                custom_palette_name = "Custom Palette"
                self.PaletteCombox.addItem(custom_palette_name)
                self.PaletteCombox.setCurrentText(custom_palette_name)
        if self.PaletteCombox.itemText(index) == "Flood":
            self.custom_palette = {'Low': '#b4c8d4', 'Medium': '#89a9bd', 'High': '#416073'} # palette for flood
        if self.PaletteCombox.itemText(index) == "Landslide":
            self.custom_palette = {'Low': '#FED8FD', 'Medium': '#FEB1FE', 'High': '#D864B1'}


    def get_config(self):
        return {
            "shock_layer": self.InputShockLayer.filePath(),
            "functions": self.FunctionCombox.checkedItems(),
            "palette": self.custom_palette
        }

class SlowShockConfigDialog(QDialog):
    def __init__(self, shock_name, parent=None):
        super().__init__(parent)
        self.shock_name = shock_name
        self.setupUi()

    def setupUi(self):
        self.setWindowTitle("Slow Shock")
        self.setGeometry(0, 0, 398, 293)

        self.layout = QVBoxLayout()

        # Shock Layers
        self.label_shock_layers = QLabel("Shock Layers", self)
        self.label_shock_layers.setGeometry(10, 40, 81, 16)
        self.ShockLayers = QgsFileWidget(self)
        self.ShockLayers.setGeometry(129, 30, 221, 27)
        self.ShockLayers.setAcceptDrops(False)
        self.ShockLayers.setStorageMode(QgsFileWidget.GetMultipleFiles)


        # Threshold
        self.label_threshold = QLabel("Threshold", self)
        self.label_threshold.setGeometry(166, 110, 71, 20)
        self.Threshold = QgsSpinBox(self)
        self.Threshold.setGeometry(260, 110, 90, 21)

        # Palette
        self.label_palette = QLabel("Palette", self)
        self.label_palette.setGeometry(20, 230, 91, 16)
        self.PaletteCombox = QComboBox(self)
        self.PaletteCombox.setGeometry(140, 230, 231, 22)
        self.PaletteCombox.addItems(["Drought", "Erosion", "Define new palette..."])
        self.PaletteCombox.currentIndexChanged.connect(self.check_define_palette)


        # Buttons
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        self.button_box.setGeometry(30, 240, 341, 32)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)

        self.layout.addWidget(self.label_shock_layers)
        self.layout.addWidget(self.ShockLayers)
        self.layout.addWidget(self.label_threshold)
        self.layout.addWidget(self.Threshold)
        self.layout.addWidget(self.label_palette)
        self.layout.addWidget(self.PaletteCombox)
        self.layout.addWidget(self.PaletteCombox)
        self.layout.addWidget(self.button_box)

        self.setLayout(self.layout)
        self.custom_palette = {'Low': '#F0CA6A', 'Medium': '#E3A917','High': '#6F520B'} # set the palette of drought as the default selection
    def check_define_palette(self, index):
        if self.PaletteCombox.itemText(index) == "Define new palette...":
            dialog = DefinePaletteDialog(self)
            if dialog.exec_() == QDialog.Accepted:
               self.custom_palette = dialog.get_palette()
                    # Add custom palette to combo box
               custom_palette_name = "Custom Palette"
               self.PaletteCombox.addItem(custom_palette_name)
               self.PaletteCombox.setCurrentText(custom_palette_name)
        if self.PaletteCombox.itemText(index) == "Drought":
            self.custom_palette = {'Low': '#F0CA6A', 'Medium': '#E3A917','High': '#6F520B'}  # palette for drought
        if self.PaletteCombox.itemText(index) == "Erosion":
            self.custom_palette = {'Low': '#F0CA6A', 'Medium': '#E3A917','High': '#6F520B'}

    def get_config(self):
        return {
            "shock_layers": self.ShockLayers.filePath(),
            "threshold": self.Threshold.value(),
            "palette": self.custom_palette
        }

class LULCConfigDialog(QDialog):
    def __init__(self, shock_name, parent=None):
        super().__init__(parent)
        self.shock_name = shock_name
        self.setupUi()


    def setupUi(self):
        self.setWindowTitle("ICA LULC Classifier")
        self.setGeometry(0, 0, 400, 300)

        self.layout = QVBoxLayout()

        # Past Land Use
        self.label_past_lu = QLabel("Past Land Use", self)
        self.label_past_lu.setGeometry(20, 30, 81, 16)
        self.PastLU = QgsFileWidget(self)
        self.PastLU.setGeometry(129, 20, 241, 27)
        self.PastLU.setStorageMode(QgsFileWidget.GetMultipleFiles)

        # Recent Land Use
        self.label_recent_lu = QLabel("Recent Land Use", self)
        self.label_recent_lu.setGeometry(20, 70, 91, 16)
        self.RecentLU = QgsFileWidget(self)
        self.RecentLU.setGeometry(130, 60, 241, 27)
        self.RecentLU.setStorageMode(QgsFileWidget.GetMultipleFiles)

        # Buttons
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        self.button_box.setGeometry(30, 240, 341, 32)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)

        self.layout.addWidget(self.label_past_lu)
        self.layout.addWidget(self.PastLU)
        self.layout.addWidget(self.label_recent_lu)
        self.layout.addWidget(self.RecentLU)
        #self.layout.addWidget(self.label_adm_layer)
        #self.layout.addWidget(self.Adm)
        #self.layout.addWidget(self.label_proj)
        #self.layout.addWidget(self.OutputProj)
        # self.layout.addWidget(self.label_output_file)
        # self.layout.addWidget(self.OutputDir)
        self.layout.addWidget(self.button_box)

        self.setLayout(self.layout)

    def get_config(self):
        return {
            "past_lu": self.PastLU.filePath(),
            "recent_lu": self.RecentLU.filePath(),
        }

# if the user want to define a natural shock
class ShockParameterDialog(QDialog):
    def __init__(self, text, parent=None):
        super().__init__(parent)
        self.shock_name = text
        self.setWindowTitle("Add Parameters")
        self.setGeometry(100, 100, 400, 200)

        self.layout = QVBoxLayout()

        self.form_layout = QFormLayout()

        self.label_shapefile = QLabel("Shapefile:", self)
        self.shock_file_edit = QLineEdit(self)
        self.shock_file_edit.setReadOnly(True)

        self.select_file_button = QPushButton("Select Shapefile", self)
        self.select_file_button.clicked.connect(self.select_shapefile)

        self.label_column = QLabel("Select Column:", self)
        self.column_combo_box = QComboBox(self)

        self.form_layout.addRow(self.label_shapefile, self.shock_file_edit)
        self.form_layout.addRow("", self.select_file_button)
        self.form_layout.addRow(self.label_column, self.column_combo_box)

        self.layout.addLayout(self.form_layout)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)

        self.layout.addWidget(self.button_box)
        self.setLayout(self.layout)

    def select_shapefile(self):
        shapefile_path, _ = QFileDialog.getOpenFileName(self, "Select Shapefile", "", "Shapefiles (*.shp)")
        if shapefile_path:
            self.shock_file_edit.setText(shapefile_path)
            self.load_columns(shapefile_path)
            print("SI file: ", shapefile_path)

    def load_columns(self, shapefile_path):
        layer = QgsVectorLayer(shapefile_path, "Selected Shapefile", "ogr")
        if not layer.isValid():
            QMessageBox.critical(self, "Error", "Failed to load shapefile.")
            return

        fields = layer.fields()
        self.column_combo_box.clear()
        for field in fields:
            self.column_combo_box.addItem(field.name())

    def get_config(self):
        return {
            "shapefile_path": self.shock_file_edit.text(),
            "selected_column": self.column_combo_box.currentText()
        }

# A class to select palette. there are pre-defined palette, and users can define their own palette if required.
class DefinePaletteDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi()

    def setupUi(self):
        self.setWindowTitle("Define New Palette")
        self.setGeometry(100, 100, 300, 200)

        self.layout = QVBoxLayout()

        # Define labels and buttons for selecting colors
        self.label_low = QLabel("Low Class Color", self)
        self.button_low = QPushButton("Select Color", self)
        self.button_low.clicked.connect(self.select_low_color)

        self.label_medium = QLabel("Medium Class Color", self)
        self.button_medium = QPushButton("Select Color", self)
        self.button_medium.clicked.connect(self.select_medium_color)

        self.label_high = QLabel("High Class Color", self)
        self.button_high = QPushButton("Select Color", self)
        self.button_high.clicked.connect(self.select_high_color)

        self.layout.addWidget(self.label_low)
        self.layout.addWidget(self.button_low)
        self.layout.addWidget(self.label_medium)
        self.layout.addWidget(self.button_medium)
        self.layout.addWidget(self.label_high)
        self.layout.addWidget(self.button_high)

        # Add dialog buttons
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.layout.addWidget(self.button_box)

        self.setLayout(self.layout)

        # Initial colors
        self.low_color = None
        self.medium_color = None
        self.high_color = None

    def select_low_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.low_color = color
            self.button_low.setStyleSheet(f"background-color: {color.name()};")

    def select_medium_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.medium_color = color
            self.button_medium.setStyleSheet(f"background-color: {color.name()};")

    def select_high_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.high_color = color
            self.button_high.setStyleSheet(f"background-color: {color.name()};")

    def get_palette(self):
        return {
            "Low": self.low_color.name() if self.low_color else None,
            "Medium": self.medium_color.name() if self.medium_color else None,
            "High": self.high_color.name() if self.high_color else None
        }

def run(self):
    dialog = ica_map_v2Dialog(self.iface)
    dialog.exec_()
